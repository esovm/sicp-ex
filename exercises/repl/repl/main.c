#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "evaluator.h"
#include "parser.h"
#include "sexp.h"
#include "scheme.h"

// Code generated by 5.52

typedef enum { entry19, after_call15, done20 } easy_prog_continues;
static Sexp easy_prog()
{
  Sexp cont = MakeNumber((easy_prog_continues)done20);
  Sexp env = setup_environment();
  Sexp argl = MakeNull();
  Sexp proc = MakeNull();
  Sexp val = MakeNull();

  val = make_compiled_procedure(MakeNumber((easy_prog_continues)entry19), env);
  goto after_lambda18;
entry19:
  env = compiled_procedure_env(proc);
  env = extend_environment(MakeNull(), argl, env);
  val = MakeNumber(0);
  goto cont_;
after_lambda18:
  define_variable_bang(MakeSymbol("func"), val, env);
  val = MakeSymbol("ok");
  proc = lookup_variable_value(MakeSymbol("func"), env);
  argl = MakeNull();
  if (GetBoolValue(primitive_procedurep(proc)))
    goto primitive_branch17;
compiled_branch16:
  cont = MakeNumber((easy_prog_continues)after_call15);
  val = compiled_procedure_entry(proc);
  goto val_;
primitive_branch17:
  val = apply_primitive_procedure(proc, argl);
after_call15:
  goto done20;
val_:
  switch (GetNumberValue(val))
  {
  case entry19: goto entry19;
  case after_call15: goto after_call15;
  case done20: goto done20;
  }
cont_:
  switch (GetNumberValue(cont))
  {
  case entry19: goto entry19;
  case after_call15: goto after_call15;
  case done20: goto done20;
  }
done20:
  return val;
}

typedef enum { entry25, proc_return32, after_call21, done33 } factorial_5_prog_continues;
static Sexp factorial_5_prog()
{
  Sexp cont = MakeNumber((factorial_5_prog_continues)done33);
  Sexp env = setup_environment();
  Sexp arg1 = MakeNull();
  Sexp arg2 = MakeNull();
  Sexp proc = MakeNull();
  Sexp argl = MakeNull();
  Sexp val = MakeNull();

  val = make_compiled_procedure(MakeNumber((factorial_5_prog_continues)entry25), env);
  goto after_lambda24;
entry25:
  env = compiled_procedure_env(proc);
  env = extend_environment(MakePair(MakeSymbol("n"), MakeNull()), argl, env);
  arg1 = lexical_address_lookup(MakePair(MakeNumber(0), MakeNumber(0)), env);
  arg2 = MakeNumber(1);
  val = number_equals(arg1, arg2);
  if (GetBoolValue(falsep(val)))
    goto false_branch27;
true_branch28:
  val = MakeNumber(1);
  goto cont_;
false_branch27:
  save(env);
  save(cont);
  proc = lookup_variable_value(MakeSymbol("factorial"), env);
  arg1 = lexical_address_lookup(MakePair(MakeNumber(0), MakeNumber(0)), env);
  arg2 = MakeNumber(1);
  val = number_minus(arg1, arg2);
  argl = list1(val);
  if (GetBoolValue(primitive_procedurep(proc)))
    goto primitive_branch31;
compiled_branch30:
  cont = MakeNumber((factorial_5_prog_continues)proc_return32);
  val = compiled_procedure_entry(proc);
  goto val_;
proc_return32:
  arg1 = val;
  goto after_call29;
primitive_branch31:
  arg1 = apply_primitive_procedure(proc, argl);
after_call29:
  cont = restore();
  env = restore();
  arg2 = lexical_address_lookup(MakePair(MakeNumber(0), MakeNumber(0)), env);
  val = number_multiply(arg1, arg2);
  goto cont_;
after_if26:
after_lambda24:
  define_variable_bang(MakeSymbol("factorial"), val, env);
  val = MakeSymbol("ok");
  proc = lookup_variable_value(MakeSymbol("factorial"), env);
  val = MakeNumber(5);
  argl = list1(val);
  if (GetBoolValue(primitive_procedurep(proc)))
    goto primitive_branch23;
compiled_branch22:
  cont = MakeNumber((factorial_5_prog_continues)after_call21);
  val = compiled_procedure_entry(proc);
  goto val_;
primitive_branch23:
  val = apply_primitive_procedure(proc, argl);
after_call21:
  goto done33;
val_:
  switch (GetNumberValue(val))
  {
  case entry25: goto entry25;
  case proc_return32: goto proc_return32;
  case after_call21: goto after_call21;
  case done33: goto done33;
  }
cont_:
  switch (GetNumberValue(cont))
  {
  case entry25: goto entry25;
  case proc_return32: goto proc_return32;
  case after_call21: goto after_call21;
  case done33: goto done33;
  }
done33:
  return val;
}

// Main Code:

typedef enum
{
  ev_appl_accum_last_arg,
  ev_appl_accumulate_arg,
  ev_appl_did_operator,
  ev_appl_did_operator_no_restore,
  ev_cond_after_pred,
  ev_let_star_after_transformation,
  ev_sequence_continue,
  ev_definition_1,
  done,
  ev_if_decide,
  ev_assignment_1,
  ev_or_after_clause,
  ev_and_after_clause
} Continues;

int main();
void CompTest(Sexp actual, Sexp expected);
void EvalTest(char* raw, Sexp expectedVal);
void ParseTest(char* raw, Sexp expectedParse);
Sexp Run(Sexp* e, Sexp* extra);

int main()
{
  goto now;

  printf("Parsing Tests:\n");
  ParseTest("#f", MakeBool(0)); 
  ParseTest("#t", MakeBool(1));
  ParseTest("42", MakeNumber(42));
  ParseTest("501", MakeNumber(501));
  ParseTest("-11", MakeNumber(-11));
  ParseTest("\"abc\"", MakeString("abc"));
  ParseTest("xyz", MakeSymbol("xyz"));
  ParseTest("(+ 2 2)", list3(MakeSymbol("+"), MakeNumber(2), MakeNumber(2)));
  ParseTest("'#t", MakeBool(1));
  ParseTest("'2", MakeNumber(2));
  ParseTest("'a", MakeQuote(MakeSymbol("a")));
  ParseTest("'\"abc\"", MakeString("abc"));
  ParseTest("'()", MakeQuote(MakeNull()));
  ParseTest("'(a)", MakeQuote(list1(MakeSymbol("a"))));
  ParseTest("-", MakeSymbol("-"));

  printf("\nEvaluation Tests:\n");
  EvalTest("(* 5 2)", MakeNumber(10));
  EvalTest("(map2 list '(a) '(b))", list1(list2(MakeSymbol("a"), MakeSymbol("b"))));
  EvalTest("(list)", MakeNull());
  EvalTest("(list 1)", list1(MakeNumber(1)));
  EvalTest("(list 1 2)", list2(MakeNumber(1), MakeNumber(2)));
  EvalTest("(list 1 2 3)", list3(MakeNumber(1), MakeNumber(2), MakeNumber(3)));
  EvalTest("(let ([x 5]) (let ([y x]) y))", MakeNumber(5));
  EvalTest("(let ([x 5]) (let ([y (* x 2)]) y))", MakeNumber(10));
  
  printf("\nTests from 4.1:\n");
  EvalTest("5", MakeNumber(5));
  EvalTest("\"abc\"", MakeString("abc"));
  EvalTest("'(+ 2 2)", list3(MakeSymbol("+"), MakeNumber(2), MakeNumber(2)));
  EvalTest("(begin (define x 5) (set! x 6) x)", MakeNumber(6));
  EvalTest("(begin (define x 5) x)", MakeNumber(5));
  EvalTest("(begin (define (x) 5) (x))", MakeNumber(5));
  EvalTest("(begin (if 0 1 2))", MakeNumber(1));
  EvalTest("(if #t 1 2)", MakeNumber(1));
  EvalTest("(if #f 1 2)", MakeNumber(2));
  EvalTest("(begin\n" 
           "  (define plus-one (lambda (x) (+ x 1)))\n"
           "  (plus-one 1))",
           MakeNumber(2));
  EvalTest("(begin 1 2 3 4)", MakeNumber(4));
  EvalTest("(cond [else 0])", MakeNumber(0));
  EvalTest("(cond [#t 0] [#f 1] [else 2])", MakeNumber(0));
  EvalTest("(cond [#f 0] [#t 1] [else 2])", MakeNumber(1));
  EvalTest("(cond [#f 0] [#f 1] [else 2])", MakeNumber(2));
  EvalTest("(+ 2 2)", MakeNumber(4));

  printf("\nTests from 4.4:\n");
  EvalTest("(and)", MakeBool(1));
  EvalTest("(and #t)", MakeBool(1));
  EvalTest("(and #t #f)", MakeBool(0));
  EvalTest("(and #f #t)", MakeBool(0));
  EvalTest("(or)", MakeBool(0));
  EvalTest("(or #t)", MakeBool(1));
  EvalTest("(or #t #f)", MakeBool(1));
  EvalTest("(or #f #t)", MakeBool(1));

  printf("\nTests from 4.5:\n");
  EvalTest("(cond [2 => +] [else 1])", MakeNumber(2));
  EvalTest("(cond [#f => +] [else 1])", MakeNumber(1));

  printf("\nTests from 4.6:\n");
  EvalTest("(let () 5)", MakeNumber(5));
  EvalTest("(let ([x 5]) x)", MakeNumber(5));
  EvalTest("(let ([x (+ 2 2)]\n"
           "      [y (- 10 5)])\n"
           "  (+ x y))",
           MakeNumber(9));
  EvalTest("(let ([x 5])\n"
           "  (define y (+ x x))\n"
           "  y)",
           MakeNumber(10));

  printf("\nTests from 4.7:\n");
  EvalTest("(let* () 5)", MakeNumber(5));
  EvalTest("(let* ([x 5]) x)", MakeNumber(5));
  EvalTest("(let* ([x 5] [y (* x 2)]) y)", MakeNumber(10));

  now:
  printf("\n5.52 C Compiler Tests:\n");
  CGCells();
  CompTest(easy_prog(), MakeNumber(0));
  CompTest(factorial_5_prog(), MakeNumber(120));

  return 0;
}

void EvalTest(char* raw, Sexp expectedVal)
{
  Sexp parsed = Parse(raw);
  if (parsed.Type == Error)
  {
    printf("Fail -- %s\n", GetStringValue(parsed));
    return;
  }

  Sexp result = Run(&parsed, &expectedVal);
  CompTest(result, expectedVal);
}

void ParseTest(char* raw, Sexp expectedParse)
{
  CGCells();

  Sexp parsed = Parse(raw);

  if (GetBoolValue(equalp(parsed, expectedParse)))
  {
    printf("Pass\n");
  }
  else
  {
    printf("Fail\n");
  }
}

void CompTest(Sexp actual, Sexp expected)
{
  CGCells();

  if (GetBoolValue(equalp(actual, expected)))
  {
    printf("Pass\n");
  }
  else
  {
    // DisplaySexp(expected, 0);
    // DisplaySexp(actual, 0);
    printf("Fail\n");
  }
}

Sexp Run(Sexp* e, Sexp* extra)
{
  // "Registers"
  Sexp argl = MakeNull();
  Sexp cont = MakeNumber((Continues)done);
  Sexp env = setup_environment();
  Sexp exp = *e;
  Sexp proc = MakeNull();
  Sexp val = MakeNull();
  Sexp unev = MakeNull();

  eval_dispatch:
    // Garbage collection
    save(argl); save(cont); save(env); save(exp); save(proc); save(val); save(unev); save(*e); save(*extra);
    CGCells();
    *extra = restore();
    *e = restore();
    unev = restore();
    val = restore();
    proc = restore();
    exp = restore();
    env = restore();
    cont = restore();
    argl = restore(); 
    
    // DisplaySexp(exp, 0);printf("\n");

    if (GetBoolValue(self_evaluatingp(exp)))
      goto ev_self_eval;
    if (GetBoolValue(variablep(exp)))
      goto ev_variable;
    if (GetBoolValue(quotedp(exp)))
      goto ev_quoted;
    if(GetBoolValue(assignmentp(exp)))
      goto ev_assignment;
    if(GetBoolValue(definitionp(exp)))
      goto ev_definition;
    if(GetBoolValue(ifp(exp)))
      goto ev_if;
    if(GetBoolValue(lambdap(exp)))
      goto ev_lambda;
    if(GetBoolValue(beginp(exp)))
      goto ev_begin;
    if(GetBoolValue(condp(exp)))
      goto ev_cond;
    if(GetBoolValue(is_andp(exp)))
      goto ev_and;
    if(GetBoolValue(is_orp(exp)))
      goto ev_or;
    if(GetBoolValue(is_letp(exp)))
      goto ev_let;
    if(GetBoolValue(is_let_starp(exp)))
      goto ev_let_star;
    if(GetBoolValue(symbol_applicationp(exp)))
      goto ev_symbol_application;
    if(GetBoolValue(applicationp(exp)))
      goto ev_application;
    goto unknown_expression_type;

  ev_self_eval:
    val = exp;
    goto continue_;

  ev_variable:
    val = lookup_variable_value(exp, env);
    goto continue_;

  ev_quoted:
    val = text_of_quotation(exp);
    goto continue_;
    save(unev);
  ev_lambda:
    unev = lambda_parameters(exp);
    exp = lambda_body(exp);
    val = make_procedure(unev, exp, env);
    goto continue_;

  ev_symbol_application:
    save(cont);
    unev = operands(exp);
    exp = operator(exp);
    cont = MakeNumber((Continues)ev_appl_did_operator_no_restore);
    goto eval_dispatch;

  ev_application:
    save(cont);
    save(env);
    unev = operands(exp);
    save(unev);
    exp = operator(exp);
    cont = MakeNumber((Continues)ev_appl_did_operator);
    goto eval_dispatch;
  ev_appl_did_operator:
    unev = restore(); // the operands
    env = restore();
  ev_appl_did_operator_no_restore:
    argl = empty_arglist();
    proc = val; // the operator
    if (GetBoolValue(no_operandsp(unev)))
      goto apply_dispatch;
    save(proc);
  ev_appl_operand_loop:
    save(argl);
    exp = first_operand(unev);
    if (GetBoolValue(last_operandp(unev)))
      goto ev_appl_last_arg;
    save(env);
    save(unev);
    cont = MakeNumber((Continues)ev_appl_accumulate_arg);
    goto eval_dispatch;
  ev_appl_accumulate_arg:
    unev = restore();
    env = restore();
    argl = restore();
    argl = adjoin_arg(val, argl);
    unev = rest_operands(unev);
    goto ev_appl_operand_loop;
  ev_appl_last_arg:
    cont = MakeNumber((Continues)ev_appl_accum_last_arg);
    goto eval_dispatch;
  ev_appl_accum_last_arg:
    argl = restore();
    argl = adjoin_arg(val, argl);
    proc = restore();
    goto apply_dispatch;

  apply_dispatch:
    if (GetBoolValue(primitive_procedurep(proc)))
      goto primitive_apply;
    if (GetBoolValue(compound_procedurep(proc)))
      goto compound_apply;
    goto unknown_procedure_type;
  primitive_apply:
    val = apply_primitive_procedure(proc, argl);
    cont = restore();
    goto continue_;
  compound_apply:
    unev = procedure_parameters(proc);
    env = procedure_environment(proc);
    env = extend_environment(unev, argl, env);
    unev = procedure_body(proc);
    goto ev_sequence;

  ev_begin:
    unev = begin_actions(exp);
    save(cont);
    goto ev_sequence;
  ev_sequence:
    exp = first_exp(unev);
    if (GetBoolValue(last_expp(unev)))
      goto ev_sequence_last_exp;
    save(unev);
    save(env);
    cont = MakeNumber((Continues)ev_sequence_continue);
    goto eval_dispatch;
  ev_sequence_continue:
    env = restore();
    unev = restore();
    unev = rest_exps(unev);
    goto ev_sequence;
  ev_sequence_last_exp:
    cont = restore();
    goto eval_dispatch;

  ev_if:
    save(exp); //save expression for later
    save(env);
    save(cont);
    cont = MakeNumber((Continues)ev_if_decide);
    exp = if_predicate(exp);
    goto eval_dispatch;
  ev_if_decide:
    cont = restore();
    env = restore();
    exp = restore();
    if (val.Type != Bool || GetBoolValue(val))
      goto ev_if_consequent;
  // ev_if_alternative: // (fall-through label)
    exp = if_alternative(exp);
    goto eval_dispatch;
  ev_if_consequent:
    exp = if_consequent(exp);
    goto eval_dispatch;
// 
  ev_assignment:
    unev = assignment_variable(exp);
    save(unev); // save variable for later
    exp = assignment_value(exp);
    save(env);
    save(cont);
    cont = MakeNumber((Continues)ev_assignment_1);
    goto eval_dispatch;
  ev_assignment_1:
    cont = restore();
    env = restore();
    unev = restore();
    set_variable_value_bang(unev, val, env);
    val = MakeSymbol("ok");
    goto continue_;

  ev_definition:
    unev = definition_variable(exp);
    save(unev); // save variable for later
    exp = definition_value(exp);
    save(env);
    save(cont);
    cont = MakeNumber((Continues)ev_definition_1);
    goto eval_dispatch;
  ev_definition_1:
    cont = restore();
    env = restore();
    unev = restore();
    define_variable_bang(unev, val, env);
    val = MakeSymbol("ok");
    goto continue_;

  ev_and:
    exp = and_clauses(exp); // clauses
    if (GetBoolValue(nullp(exp)))
    {
      val = MakeBool(1);
      goto continue_;
    }
  ev_and_clause:
    save(cont);
    save(exp);
    save(env);
    cont = MakeNumber((Continues)ev_and_after_clause);
    exp = car(exp);
    goto eval_dispatch;
  ev_and_after_clause:
    env = restore(env);
    exp = cdr(restore(exp)); // clauses
    cont = restore(cont);
    if ((val.Type == Bool && !GetBoolValue(val)) || GetBoolValue(nullp(exp)))
    {
      goto continue_;
    }
    goto ev_and_clause;

  ev_or:
    exp = or_clauses(exp); // clauses
    if (GetBoolValue(nullp(exp)))
    {
      val = MakeBool(0);
      goto continue_;
    }
  ev_or_clause:
    save(cont);
    save(exp);
    save(env);
    cont = MakeNumber((Continues)ev_or_after_clause);
    exp = car(exp);
    goto eval_dispatch;
  ev_or_after_clause:
    env = restore(env);
    exp = cdr(restore(exp)); // clauses
    cont = restore(cont);
    if (val.Type != Bool || GetBoolValue(val) || GetBoolValue(nullp(exp)))
    {
      goto continue_;
    }
    goto ev_or_clause;

  ev_let:
    exp = let_to_combination(exp);
    goto eval_dispatch;

  ev_let_star:
    save(cont);
    cont = MakeNumber((Continues)ev_let_star_after_transformation);
    exp = list2(MakeSymbol("let*->nested-lets"), MakeQuote(exp));
    goto eval_dispatch;
  ev_let_star_after_transformation:
    cont = restore();
    exp = val;
    goto eval_dispatch;

  ev_cond:
    exp = cond_clauses(exp); // exp is clauses
  ev_cond_loop:
    val = car(exp); // val is 1st clause
    if (GetBoolValue(cond_else_clausep(val))) // if 1st clause is else
      goto ev_cond_evaluate_actions; // eval 1st clause actions
    save(cont);
    save(exp);
    cont = MakeNumber((Continues)ev_cond_after_pred);
    exp = cond_predicate(val);
    goto eval_dispatch;
  ev_cond_after_pred:
    exp = restore(); // exp is clauses
    cont = restore();
    if (val.Type != Bool || GetBoolValue(val)) // if the predicate is true
      goto ev_cond_evaluate_actions; //  eval 1st clause actions
    exp = cdr(exp);
    goto ev_cond_loop;

  ev_cond_evaluate_actions:
    exp = car(exp); // exp is clause
    if (GetBoolValue(cond_is_arrowp(exp)))
      goto ev_cond_arrow_actions;

  // ev_cond_regular_actions: // (fall-through label)
    exp = cond_actions(exp); // exp is actions of the clause
    exp = cons(MakeSymbol("begin"), exp); // ; exp is actions prepended with "begin"
    goto eval_dispatch;

  ev_cond_arrow_actions:
    val = cons(val, MakeNull()); // val is (predicate_value)
    exp = cond_arrow_proc(exp); // exp is the proc of the cond_arrow
    exp = cons(exp, val); // exp is (proc predicate_value)
    goto eval_dispatch;

  unknown_expression_type:
    return MakeError("unknown expression type");

  unknown_procedure_type:
    return MakeError("unknown procedure type");

  // NEW -- Workaround for "labels as values"
  continue_:
    switch (GetNumberValue(cont))
    {
      case done: goto done;
      case ev_appl_accum_last_arg: goto ev_appl_accum_last_arg;
      case ev_appl_accumulate_arg: goto ev_appl_accumulate_arg;
      case ev_appl_did_operator: goto ev_appl_did_operator;
      case ev_appl_did_operator_no_restore: goto ev_appl_did_operator_no_restore;
      case ev_cond_after_pred: goto ev_cond_after_pred;
      case ev_sequence_continue: goto ev_sequence_continue;
      case ev_definition_1: goto ev_definition_1;
      case ev_if_decide: goto ev_if_decide;
      case ev_assignment_1: goto ev_assignment_1;
      case ev_let_star_after_transformation: goto ev_let_star_after_transformation;
      case ev_or_after_clause: goto ev_or_after_clause;
      case ev_and_after_clause: goto ev_and_after_clause;
    }

  done:
    return val;
}
