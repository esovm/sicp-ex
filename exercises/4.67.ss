#|

Exercise 4.67: Devise a way to install a loop detector in
the query system so as to avoid the kinds of simple loops
illustrated in the text and in Exercise 4.64. The general
idea is that the system should maintain some sort of history
of its current chain of deductions and should not begin
processing a query that it is already working on. Describe
what kind of information (patterns and frames) is included
in this history, and how the check should be made. (After
you study the details of the query-system implementation in
Section 4.4.4, you may want to modify the system to include
your loop detector.)

|#

(load-ex "4.66")

#| Answer

My first inclination was to check for redundant queries in qeval. This would be
nice because you could memoize values but it doesn't work because (1) the entire
idea is that some queries will never return and (2) qeval operates on streams
and how could it examine that streams possibly infinite contents (although you
could probably do this with a lot of refactoring)."

I think the prompt doesn't give enough direction. "Loop detector" sounds like
something at a high level of abstraction however all that is needed for the
given examples is an "infinite recursuion detector" that limits itself to the
rules subsystem (even though other subsystems require trivial changes to pass
the history along). Perhaps I also misled myself in trying to create a simple
patch rather than a solution involving trival pervasive changes.

It would be nice if the book described how we should consider the incomplete
answers generated by the system. In the Mickey example, we get the desired
answer but for an example in 4.68, we do not.

Every implementation online seems to break the test case:

(do-query-n inf-db '(ones ?x) 5)

It seems the history system needs to take into account what conclusion we're
trying to reach?

I'm not sure how a loop detecting query system is supposed to interface with
infinite result streams, and the section itself does not demonstrate any actual
examples of infinite result streams even though such examples are key to some of
the exercises.

|#

#| Code from book --- 4.4.4.2 The Evaluator -- modified |#
(define (qeval query frame-stream h)
  (let ([qproc (get (type query) 'qeval)])
    (if qproc
        (qproc (contents query) frame-stream h)
        (simple-query query frame-stream h))))

(define (simple-query query-pattern frame-stream h)
  (stream-flatmap
    (lambda (frame)
      (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame h))))
    frame-stream))

(define (conjoin conjuncts frame-stream h)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts) frame-stream h)
               h)))

(put 'and 'qeval conjoin)

(define (disjoin disjuncts frame-stream h)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
        (qeval (first-disjunct disjuncts) frame-stream h)
        (delay (disjoin (rest-disjuncts disjuncts) frame-stream h)))))

(put 'or 'qeval disjoin)

(define (negate operands frame-stream h)
  (stream-flatmap
    (lambda (frame)
      (if (stream-null? (qeval (negated-query operands)
                               (singleton-stream frame)
                               h))
          (singleton-stream frame)
          the-empty-stream))
    frame-stream))

(put 'not 'qeval negate)

(define (lisp-value call frame-stream h)
  (stream-flatmap
    (lambda (frame)
      (if (execute
            (instantiate
             call
             frame
             (lambda (v f)
               (error "lisp-value" "unknown pat var" v))))
          (singleton-stream frame)
          the-empty-stream))
    frame-stream))

(put 'lisp-value 'qeval lisp-value)

; changed user-initial-environment to (scheme-environment)
(define (execute exp)
  (apply (eval (pred exp) (interaction-environment))
         (args exp)))

(define (always-true ignore frame-stream h) frame-stream)

(put 'always-true 'qeval always-true)

#| Code from book -- 4.4.4.4 Rules and Unification -- updated |#
(define (apply-rules pattern frame h)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame h))
                  (fetch-rules pattern frame)))

;;; (do-query-n inf-db '(ones ?x) 5)

(define (apply-a-rule rule query-pattern query-frame history)
  (let* ([clean-rule (rename-variables-in rule)]
         [unify-result (unify-match query-pattern (conclusion clean-rule) query-frame)])
    (if (eq? unify-result 'failed)
        the-empty-stream
        (let* ([query (rule-body clean-rule)]
               [frame unify-result]
               [inst (instantiate query frame (lambda (v f) '?))])
          (if (in-history? inst history)
              the-empty-stream
              (let* ([next-hist (add-to-history inst history)]
                     [ret (qeval query (singleton-stream frame) next-hist)])
                ret))))))

#| Updated test functions |#
(define (top-level-qeval q)
  (qeval q (singleton-stream '()) '()))

#| History infrastructure |#

(define (in-history? x history)
  (member x history))

(define (add-to-history x history)
  (cons x history))

(define (contains-qm x)
  (if (pair? x)
      (or (contains-qm (car x))
          (contains-qm (cdr x)))
      (eq? '? x)))

#| Tests -- 1 regression test fails (the infinite stream test from 4.55) |#
(define db467 '(
  (married A B)
  (rule (married ?x ?y) 
        (married ?y ?x))))
(define q467 '(married B ?who))

(define-test (do-query db467 q467)
             '((married B A)))

#| Notes

;;; debug output w/ pretty-printing tweaked by hand
;;; query, frame, query instantiated with frame

> (do-query db467 q467)

(married (? 1 y) (? 1 x))
([(? who) . (? 1 y)] 
 [(? 1 x) . Mickey])
(married ? Mickey)

(married (? 2 y) (? 2 x))
([(? 2 y) . Mickey] 
 [(? 1 y) ? 2 x] 
 [(? who) ? 1 y] 
 [(? 1 x) . Mickey])
(married Mickey ?)

(married (? 3 y) (? 3 x))
([(? 2 x) ? 3 y] 
 [(? 3 x) . Mickey] 
 [(? 2 y) . Mickey] 
 [(? 1 y) ? 2 x] 
 [(? who) ? 1 y] [(? 1 x) . Mickey])
(married ? Mickey)

I tried an algorithm like
  Check if pending
  Add to pending
  Do qeval
  Remove from pending

This doesn't work because as soon as you get an assertion match, the rules part
of the stream is delayed and the qeval returns.

Checkout out how to preserve ability generate all possible sequences of ones:

|#
